use std::collections::HashMap;

pub fn ocr(image: &str, marker: char) -> Option<String> {
    let image = image.trim_end();
    let ids = map_to_id(image, marker)?;
    let letter_map = get_letter_map();
    let ocr = ids.iter()
        .map(|id| letter_map.get(id).unwrap_or(&'?'))
        .collect();
    Some(ocr)
}

fn map_to_id(image: &str, marker: char) -> Option<Vec<u64>> {
    let width = image.find('\n')?;
    let height = image.len() / width;
    let image = image.as_bytes();
    let marker = marker as u8;
    
    let mut id = 0u64;
    let mut letter_width = 0usize;

    let mut ids = Vec::new();

    for x in 0..width {
        let col: Vec<bool> = (0..height)
            .map(|y| image[x + y * (width + 1)] == marker)
            .collect();
        if col.iter().all(|&b| !b) {
            if id != 0 { ids.push(id); }
            id = 0;
            letter_width = 0;
        } else {
            if height == 6 && letter_width == 5 {
                ids.push(id);
                id = 0;
                letter_width = 0;
            }
            id = col.iter()
                .fold(id, |acc, &b| (acc << 1) + if b { 1 } else { 0 });
            letter_width += 1;
        }
    }
    if id != 0 { ids.push(id) };
    Some(ids)
}

fn get_letter_map() -> HashMap<u64, char> {
    let letters6 = "ABCEFGHIJKLOPRSUYZ";

    let letter_forms6 = r"
.##..###...##..####.####..##..#..#.###...##.#..#.#.....##..###..###...###.#..#.#...#.####
#..#.#..#.#..#.#....#....#..#.#..#..#.....#.#.#..#....#..#.#..#.#..#.#....#..#.#...#....#
#..#.###..#....###..###..#....####..#.....#.##...#....#..#.#..#.#..#.#....#..#..#.#....#.
####.#..#.#....#....#....#.##.#..#..#.....#.#.#..#....#..#.###..###...##..#..#...#....#..
#..#.#..#.#..#.#....#....#..#.#..#..#..#..#.#.#..#....#..#.#....#.#.....#.#..#...#...#...
#..#.###...##..####.#.....###.#..#.###..##..#..#.####..##..#....#..#.###...##....#...####
    ".trim();

    let letters10 = "ABCEFGHJKLNPRXZ";

    let letter_forms10 = r"
..##...#####...####..######.######..####..#....#....###.#....#.#......#....#.#####..#####..#....#.######
.#..#..#....#.#....#.#......#......#....#.#....#.....#..#...#..#......##...#.#....#.#....#.#....#......#
#....#.#....#.#......#......#......#......#....#.....#..#..#...#......##...#.#....#.#....#..#..#.......#
#....#.#....#.#......#......#......#......#....#.....#..#.#....#......#.#..#.#....#.#....#..#..#......#.
#....#.#####..#......#####..#####..#......######.....#..##.....#......#.#..#.#####..#####....##......#..
######.#....#.#......#......#......#..###.#....#.....#..##.....#......#..#.#.#......#..#.....##.....#...
#....#.#....#.#......#......#......#....#.#....#.....#..#.#....#......#..#.#.#......#...#...#..#...#....
#....#.#....#.#......#......#......#....#.#....#.#...#..#..#...#......#...##.#......#...#...#..#..#.....
#....#.#....#.#....#.#......#......#...##.#....#.#...#..#...#..#......#...##.#......#....#.#....#.#.....
#....#.#####...####..######.#.......###.#.#....#..###...#....#.######.#....#.#......#....#.#....#.######
    ".trim();

    let mut letter_map = HashMap::new();

    populate_letter_map(&mut letter_map, letter_forms6, letters6);
    populate_letter_map(&mut letter_map, letter_forms10, letters10);

    letter_map
}

fn populate_letter_map(
    letter_map: &mut HashMap<u64, char>, 
    letter_forms: &str, 
    letters: &str
) {
    map_to_id(letter_forms, '#')
        .unwrap()
        .iter()
        .zip(letters.chars()) 
        .for_each(|(&id, c)| {
            letter_map.insert(id, c);
        });
}

#[cfg(test)]
mod tests {
    use super::*;
    fn ocr_test(output: &str, letter_forms: &str) -> bool {
        Some(output.to_string()) == ocr(letter_forms, '#')
    }


    #[test]
    fn size6() {
        let output = "ABCEFGHIJKLOPRSUYZ";
        let letter_forms = r"
.##..###...##..####.####..##..#..#.###...##.#..#.#.....##..###..###...###.#..#.#...#.####
#..#.#..#.#..#.#....#....#..#.#..#..#.....#.#.#..#....#..#.#..#.#..#.#....#..#.#...#....#
#..#.###..#....###..###..#....####..#.....#.##...#....#..#.#..#.#..#.#....#..#..#.#....#.
####.#..#.#....#....#....#.##.#..#..#.....#.#.#..#....#..#.###..###...##..#..#...#....#..
#..#.#..#.#..#.#....#....#..#.#..#..#..#..#.#.#..#....#..#.#....#.#.....#.#..#...#...#...
#..#.###...##..####.#.....###.#..#.###..##..#..#.####..##..#....#..#.###...##....#...####        
        ".trim();
        assert!(ocr_test(output, letter_forms));
    }

    #[test]
    fn size10() {
        let output = "ABCEFGHJKLNPRXZ";
        let letter_forms = r"
..##...#####...####..######.######..####..#....#....###.#....#.#......#....#.#####..#####..#....#.######
.#..#..#....#.#....#.#......#......#....#.#....#.....#..#...#..#......##...#.#....#.#....#.#....#......#
#....#.#....#.#......#......#......#......#....#.....#..#..#...#......##...#.#....#.#....#..#..#.......#
#....#.#....#.#......#......#......#......#....#.....#..#.#....#......#.#..#.#....#.#....#..#..#......#.
#....#.#####..#......#####..#####..#......######.....#..##.....#......#.#..#.#####..#####....##......#..
######.#....#.#......#......#......#..###.#....#.....#..##.....#......#..#.#.#......#..#.....##.....#...
#....#.#....#.#......#......#......#....#.#....#.....#..#.#....#......#..#.#.#......#...#...#..#...#....
#....#.#....#.#......#......#......#....#.#....#.#...#..#..#...#......#...##.#......#...#...#..#..#.....
#....#.#....#.#....#.#......#......#...##.#....#.#...#..#...#..#......#...##.#......#....#.#....#.#.....
#....#.#####...####..######.#.......###.#.#....#..###...#....#.######.#....#.#......#....#.#....#.######
        ".trim();
        assert!(ocr_test(output, letter_forms));
    }

    #[test]
    fn y_bug() {
        let output = "LGYHB";
        let letter_forms = r"
#.....##..#...##..#.###..
#....#..#.#...##..#.#..#.
#....#.....#.#.####.###..
#....#.##...#..#..#.#..#.
#....#..#...#..#..#.#..#.
####..###...#..#..#.###..
        ".trim();
        assert!(ocr_test(output, letter_forms));
    }
}
